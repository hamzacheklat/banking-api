Parfait ‚úÖ ‚Äî tu veux donc que ton d√©corateur accepte des retours du style :

```python
return {"name": "foo"}, 201
```

‚Ä¶et que ce soit **le code HTTP** qui soit pris en compte, **sans l‚Äôajouter dans le mod√®le** (c‚Äôest-√†-dire qu‚Äôon ne le valide pas via Pydantic, juste on le passe au `json()`).

Voici la version **id√©ale** du d√©corateur pour ton besoin üëá

---

## ‚öôÔ∏è `@validate_response(model)` ‚Äî version avec support du code HTTP uniquement

```python
from functools import wraps
from pydantic import ValidationError
from sanic.response import json
from sanic import HTTPResponse

def validate_response(model):
    """
    Valide la r√©ponse d'un endpoint Sanic via Pydantic.
    Le handler peut retourner :
      - dict ‚Üí status=200
      - (dict, int) ‚Üí status personnalis√©
      - HTTPResponse ‚Üí inchang√©
    """
    def decorator(handler):
        @wraps(handler)
        async def wrapper(request, *args, **kwargs):
            result = await handler(request, *args, **kwargs)

            # Si la route renvoie d√©j√† une r√©ponse Sanic (ex: redirect, file, etc.)
            if isinstance(result, HTTPResponse):
                return result

            # Gestion (data, status)
            if isinstance(result, tuple) and len(result) == 2 and isinstance(result[1], int):
                data, status_code = result
            else:
                data, status_code = result, 200

            # Validation via Pydantic
            try:
                validated = model(**data)
            except ValidationError as e:
                return json({
                    "error": "Response validation failed",
                    "details": e.errors(),
                }, status=500)

            # S√©rialisation JSON + code HTTP
            return json(validated.model_dump(), status=status_code)

        return wrapper
    return decorator
```

---

## üß© Exemple d‚Äôutilisation

```python
from sanic import Sanic
from sanic_ext import Extend, validate
from pydantic import BaseModel

app = Sanic("vdb_api")
Extend(app)

class VdbResponse(BaseModel):
    name: str
    status: str

class PatchVdbBody(BaseModel):
    name: str

@app.patch("/vdbs/<vdb_name>")
@validate(json=PatchVdbBody)
@validate_response(VdbResponse)
async def patch_vdb(request, body: PatchVdbBody, vdb_name: str):
    if vdb_name == "new":
        # Cr√©ation ‚Üí 201
        return {"name": body.name, "status": "CREATED"}, 201

    # Cas normal ‚Üí 200
    return {"name": body.name, "status": "UPDATED"}
```

‚úÖ **R√©sultat :**

* `return {...}` ‚Üí HTTP 200
* `return {...}, 201` ‚Üí HTTP 201
* `return json(...)` ‚Üí inchang√©
* Si la r√©ponse ne correspond pas √† `VdbResponse`, tu obtiens :

  ```json
  {
    "error": "Response validation failed",
    "details": [...]
  }
  ```

---

## ‚öôÔ∏è Exemple avec mod√®le imbriqu√©

```python
from typing import Optional

class Details(BaseModel):
    size: int
    version: str

class VdbResponse(BaseModel):
    name: str
    status: str
    details: Optional[Details]

@app.get("/vdbs/<vdb_name>")
@validate_response(VdbResponse)
async def get_vdb(request, vdb_name: str):
    return {
        "name": vdb_name,
        "status": "READY",
        "details": {"size": 1024, "version": "1.0.0"}
    }
```

üí° Si `details.version` ou `details.size` ne respecte pas le type ‚Üí validation automatique √©choue.

---

Souhaites-tu que je te montre une version **multi-support** (qui g√®re aussi les r√©ponses `List[Model]`, genre `return [{"id": 1}, {"id": 2}]`), tout en gardant cette logique de code HTTP ?
