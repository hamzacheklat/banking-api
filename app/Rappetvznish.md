Parfait üëå ‚Äî tu veux donc :

‚û°Ô∏è Que le **rapport quotidien** s‚Äôappuie sur la **base MongoDB + index Chroma (RAG)**,
‚û°Ô∏è Pour **analyser automatiquement les erreurs/flows du jour**,
‚û°Ô∏è Et g√©n√©rer un **rapport lisible (Excel ou PDF)** que l‚Äôon peut aussi **envoyer par mail**.

On va donc combiner trois briques :

1. **Analyse RAG** (interpr√©tation intelligente des erreurs du jour)
2. **G√©n√©ration de rapport** (Excel ou PDF, au choix)
3. **Envoi automatique** (mail ou Slack, selon ton infra)

---

## ‚öôÔ∏è Architecture compl√®te

```
app/
‚îú‚îÄ‚îÄ config.py
‚îú‚îÄ‚îÄ vector_store.py
‚îú‚îÄ‚îÄ embedder.py
‚îú‚îÄ‚îÄ mongo_ingest.py
‚îú‚îÄ‚îÄ rag.py
‚îú‚îÄ‚îÄ litellm_client.py
‚îî‚îÄ‚îÄ report_generator.py  üëà (nouveau module)
```

---

## üß© √âtape 1 : rapport bas√© sur le RAG

Voici le contenu du nouveau fichier `app/report_generator.py` :

```python
import pandas as pd
from datetime import datetime
from pymongo import MongoClient
from rag import answer_query
import config
import smtplib
from email.message import EmailMessage
from io import BytesIO
from openpyxl import Workbook


def fetch_flows_for_date(date_str: str):
    """
    R√©cup√®re les documents Mongo vanish_flows pour une date donn√©e.
    """
    client = MongoClient(config.MONGO_URI)
    db = client[config.MONGO_DB]
    col = db["vanish_flows"]

    # Format attendu du champ date dans la base (√† adapter si besoin)
    query = {"DATE": {"$regex": f"^{date_str}"}}
    return list(col.find(query))


def generate_rag_summary(flow_docs):
    """
    Fait un r√©sum√© intelligent des causes d‚Äô√©chec du jour via RAG.
    """
    if not flow_docs:
        return "Aucune donn√©e pour cette date."

    joined = "\n\n".join([
        f"FLOW: {d.get('FLOW', '')}\nTASK: {d.get('TASK', '')}\nFAILURE: {d.get('FAILURE REASON', '')}"
        for d in flow_docs
    ])

    query = (
        "Analyse ces logs de flux du jour et r√©sume : "
        "1Ô∏è‚É£ les types d'erreurs r√©currents, "
        "2Ô∏è‚É£ les causes probables, "
        "3Ô∏è‚É£ les actions recommand√©es."
    )

    result = answer_query(query + "\n\n" + joined)
    return result["answer"]


def generate_excel_report(date_str: str, flow_docs, rag_summary: str):
    """
    Cr√©e un rapport Excel complet √† partir des flux + r√©sum√© RAG.
    """
    wb = Workbook()
    ws = wb.active
    ws.title = "Rapport des Flows"

    # En-t√™tes
    headers = ["DATE", "FLOW", "TASK", "JOB_ID", "SUB_ID", "FAILURE REASON", "WHAT TO DO?"]
    ws.append(headers)

    # Donn√©es
    for doc in flow_docs:
        ws.append([
            doc.get("DATE", ""),
            doc.get("FLOW", ""),
            doc.get("TASK", ""),
            doc.get("JOB_ID", ""),
            doc.get("SUB_ID", ""),
            doc.get("FAILURE REASON", ""),
            doc.get("WHAT TO DO?", ""),
        ])

    # Ajout du r√©sum√© RAG √† la fin
    ws.append([])
    ws.append(["--- R√©sum√© RAG ---"])
    for line in rag_summary.split("\n"):
        ws.append([line])

    output = BytesIO()
    wb.save(output)
    output.seek(0)
    return output.getvalue()


def send_report_via_email(recipient, subject, attachment_bytes, date_str):
    """
    Envoie le rapport Excel par e-mail.
    """
    msg = EmailMessage()
    msg["From"] = "rapport-vanish@tondomaine.com"
    msg["To"] = recipient
    msg["Subject"] = subject

    msg.set_content(f"Voici le rapport des flows du {date_str}.\n\nBonne journ√©e !")

    msg.add_attachment(
        attachment_bytes,
        maintype="application",
        subtype="vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        filename=f"rapport_flows_{date_str}.xlsx",
    )

    with smtplib.SMTP("smtp.tondomaine.com", 587) as server:
        server.starttls()
        server.login("rapport-vanish@tondomaine.com", "TON_MDP")
        server.send_message(msg)
        print(f"üìß Rapport envoy√© √† {recipient}")


def generate_daily_report(date_str=None, send_email=False, recipient=None):
    """
    Fonction principale :
    - R√©cup√®re les flows Mongo
    - G√©n√®re r√©sum√© RAG
    - Cr√©e le rapport Excel
    - L‚Äôenvoie par mail (optionnel)
    """
    if not date_str:
        date_str = datetime.now().strftime("%d/%m/%Y")

    print(f"üìÖ G√©n√©ration du rapport du {date_str}")

    flows = fetch_flows_for_date(date_str)
    rag_summary = generate_rag_summary(flows)
    excel_bytes = generate_excel_report(date_str, flows, rag_summary)

    if send_email and recipient:
        send_report_via_email(recipient, f"Rapport des flows du {date_str}", excel_bytes, date_str)
    else:
        with open(f"rapport_flows_{date_str}.xlsx", "wb") as f:
            f.write(excel_bytes)
        print(f"‚úÖ Rapport sauvegard√© : rapport_flows_{date_str}.xlsx")


if __name__ == "__main__":
    generate_daily_report(send_email=False)
```

---

## üß† Fonctionnement

1. Le script **r√©cup√®re les flux du jour depuis Mongo** (`DATE` = jour courant).
2. Il envoie le tout au **RAG** pour un r√©sum√© intelligent.
3. Il **g√©n√®re un rapport Excel** complet (identique √† tes tableaux color√©s).
4. Optionnellement, il **envoie ce rapport par e-mail**.

---

## üïê Usage

* **G√©n√©ration locale :**

  ```bash
  python app/report_generator.py
  ```

* **Envoi automatique :**

  ```bash
  python app/report_generator.py --send-email true --recipient "ops@tondomaine.com"
  ```

---

## üìä √âtape suivante possible

Si tu veux aller plus loin, je peux t‚Äôajouter :

* Un **rapport PDF plus visuel** (avec logos, mise en couleur par flow).
* Une **int√©gration Slack/Teams** (pour envoyer un r√©sum√© + le fichier).
* Une **commande RAG ‚Äúanalyse semaine‚Äù** qui compare les jours pr√©c√©dents.

---

Souhaites-tu que je t‚Äôajoute maintenant :
1Ô∏è‚É£ le **rapport PDF** (avec couleurs comme tes tableaux),
ou 2Ô∏è‚É£ l‚Äô**envoi automatique vers Slack/Teams** ?
